一、java对象的创建过程
1、类加载检查：虚拟机遇到一条new指令时，先检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，则先进行类的加载过程。

2、分配内存：有两种方式

指针碰撞：假设Java堆中的内存是规整的，用过的内存在一边，空闲的在另一边，中间有一个指针作为分界点的指示器，所分配的内存就把那个指针向空闲那边挪动一段与对象大小相等的距离。

空闲列表：如果Java堆中的内存不是规整的，虚拟机必须维护一个列表，记录哪些内存块可用的，分配时从列表中找到一块足够大的空间划分给对象，并更新列表的记录。

在划分可用空间时，会遇到线程安全的问题。解决这个问题有两种方案。第一种：对分配内存空间的动作进行同步处理--虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。另一种是把内存分配的动作安装现场划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB）。那个线程需要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。是否使用TLAB，-XX：+UseTLAB参数来设定。

3、初始化零值 将分配到的内存空间都初始化为零值，如果用TLAB，则在TLAB分配时初始化为零值。

4、设置对象头：主要设置类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。

5、执行init方法初始化。

二、对象的访问定位的两种方式
1、句柄  Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
2、直接指针  如果使用直接指针访问，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。
这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

三、String 类和常量池

1、String.intern() 如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。
2、String s1 = new String("abc");这句话创建了几个对象？答：创建了两个对象。
先有字符串"abc"放入常量池，然后 new 了一份字符串"abc"放入Java堆(字符串常量"abc"在编译期就已经确定放入常量池，而 Java 堆上的"abc"是在运行期初始化阶段才确定)，然后 Java 栈的 s1 指向Java堆上的"abc"。
